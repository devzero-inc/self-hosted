name: devzero DSH deployment

on:
  push:
    paths:
      - 'self-hosted/terraform/examples/aws/**'
    branches:
      - main
  schedule:
    - cron: '0 3 * * *'
  workflow_dispatch:

jobs:
  setup-and-test:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credential
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::484907513542:role/github-actions-oidc-role
          aws-region: us-west-1
          role-duration-seconds: 7200

      - name: Clone DevZero Self-Hosted Repository
        env:
          GH_PAT: ${{ secrets.GH_TOKEN }}
        run: |
          git clone https://$GH_PAT@github.com/devzero-inc/self-hosted.git

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Add Backend Override (Base Cluster)
        run: |
          cd self-hosted/terraform/examples/aws/base-cluster
          cat <<EOF > backend_override.tf
          terraform {
            backend "s3" {
                bucket         	   = "dsh-tf-state"
                key              	 = "base-cluster/terraform.tfstate"
                region         	   = "us-west-1"
            }
          }
          EOF

      - name: Initialize and Apply Terraform (Base Cluster)
        run: |
          cd self-hosted/terraform/examples/aws/base-cluster
          terraform init
          terraform apply -auto-approve -var="cluster_name=devzero-dsh-testing"
          echo "CLUSTER_NAME=$(terraform output -raw cluster_name)" >> $GITHUB_ENV
          echo "VPC_ID=$(terraform output -raw vpc_id)" >> $GITHUB_ENV
          echo "PUBLIC_SUBNET_IDS=$(terraform output -json public_subnet_ids | jq -c .)" >> $GITHUB_ENV
          echo "PRIVATE_SUBNET_IDS=$(terraform output -json private_subnet_ids | jq -c .)" >> $GITHUB_ENV

      - name: Update Cluster-Extensions tfvars
        run: |
          cat <<EOT > self-hosted/terraform/examples/aws/cluster-extensions/terraform.tfvars
          region = "us-west-1"
          vpc_id = "$VPC_ID"
          public_subnet_ids = $PUBLIC_SUBNET_IDS
          private_subnet_ids = $PRIVATE_SUBNET_IDS
          enable_cluster_autoscaler = false
          cluster_name = "$CLUSTER_NAME"
          EOT

      - name: Add Backend Override (Cluster Extensions)
        run: |
          cd self-hosted/terraform/examples/aws/cluster-extensions
          cat <<EOF > backend_override.tf
          terraform {
            backend "s3" {
                bucket         	   = "dsh-tf-state"
                key              	 = "cluster-extensions/terraform.tfstate"
                region         	   = "us-west-1"
            }
          }
          EOF

      - name: Initialize and Apply Cluster-Extensions
        run: |
          cd self-hosted/terraform/examples/aws/cluster-extensions
          terraform init
          terraform apply -auto-approve

      - name: Configure Kubernetes Access
        run: |
          aws eks update-kubeconfig --region us-west-1 --name $CLUSTER_NAME

      - name: Deploy Control Plane Dependencies
        run: |
          cd self-hosted/charts/dz-control-plane-deps
          make install

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.15.1/yq_linux_amd64 -O /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq

      - name: Update values.yaml for Control Plane
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          BACKEND_LICENSE_KEY: ${{ secrets.BACKEND_LICENSE_KEY }}
        run: |
          yq e -i '
            .credentials.registry = "docker.io" |
            .credentials.username = strenv(DOCKERHUB_USERNAME) |
            .credentials.password = strenv(DOCKERHUB_TOKEN) |
            .credentials.email = "garvit@devzero.io" |
            .backend.licenseKey = strenv(BACKEND_LICENSE_KEY)
          ' self-hosted/charts/dz-control-plane/values.yaml

      - name: Deploy DevZero Control Plane
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          cd self-hosted/charts/dz-control-plane
          make add-docker-creds
          make install

      - name: Validate Control Plane
        run: |
          echo -e "\nPods in namespace  devzero:"
          kubectl get pods -n devzero
          chmod +x self-hosted/.github/scripts/dsh-pod-test.sh
          self-hosted/.github/scripts/dsh-pod-test.sh
          echo -e "\nIngress in namespace  devzero:"
          kubectl get ingress -n devzero

      - name: Update values.yaml for Data Plane
        run: |
          cat <<EOT > self-hosted/charts/dz-data-plane/values.yaml
          ## @section Devzero
          devzero:
            teamId: ""
            region: "us-west-1"
            vault:
              server: "https://csi.devzero.io"
          ## @section Node Labeler
          nodeLabeler:
            enabled: true
          ## @section Credentials Configuration
          credentials:
            registry: "docker.io"
            username: "${{ secrets.DOCKERHUB_USERNAME }}"
            password: "${{ secrets.DOCKERHUB_TOKEN }}"
            email: "garvit@devzero.io"
          EOT

      - name: Deploy Data Plane Dependencies
        run: |
          cd self-hosted/charts/dz-data-plane-deps
          make install

      - name: Deploy DevZero Data Plane
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          cd self-hosted/charts/dz-data-plane
          make install

      - name: Validate Data Plane
        run: |
          kubectl get pods -n devzero-self-hosted
          kubectl get ingress -n devzero-self-hosted

      - name: Run Destroy cluster-extensions
        if: always()
        run: |
          cd self-hosted/terraform/examples/aws/cluster-extensions
          terraform destroy -auto-approve

      - name: Destroy AWS Dependencies
        if: always()
        run: |
          IGW_ID=$(aws ec2 describe-internet-gateways --filters "Name=attachment.vpc-id,Values=$VPC_ID" --query 'InternetGateways[0].InternetGatewayId' --output text)
          if [ "$IGW_ID" != "None" ]; then
            for eip in $(aws ec2 describe-addresses --filters "Name=domain,Values=vpc" --query 'Addresses[*].AllocationId' --output text); do
              aws ec2 release-address --allocation-id $eip || true
            done

            aws ec2 detach-internet-gateway --internet-gateway-id $IGW_ID --vpc-id $VPC_ID || true
            aws ec2 delete-internet-gateway --internet-gateway-id $IGW_ID || true
          fi

          for nat in $(aws ec2 describe-nat-gateways --filter "Name=vpc-id,Values=$VPC_ID" --query 'NatGateways[*].NatGatewayId' --output text); do
            ALLOC_ID=$(aws ec2 describe-nat-gateways --nat-gateway-ids $nat --query 'NatGateways[0].NatGatewayAddresses[0].AllocationId' --output text)
            aws ec2 delete-nat-gateway --nat-gateway-id $nat || true
            aws ec2 release-address --allocation-id $ALLOC_ID || true
          done

          for instance in $(aws ec2 describe-instances --filters "Name=vpc-id,Values=$VPC_ID" --query 'Reservations[*].Instances[*].InstanceId' --output text); do
            aws ec2 terminate-instances --instance-ids $instance || true
            aws ec2 wait instance-terminated --instance-ids $instance || true
          done

          for eni in $(aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$VPC_ID" --query 'NetworkInterfaces[*].NetworkInterfaceId' --output text); do
            aws ec2 delete-network-interface --network-interface-id $eni || true
          done

          for rtb in $(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=$VPC_ID" --query 'RouteTables[*].RouteTableId' --output text); do
            for assoc in $(aws ec2 describe-route-tables --route-table-ids $rtb --query 'RouteTables[0].Associations[*].RouteTableAssociationId' --output text); do
              aws ec2 disassociate-route-table --association-id $assoc || true
            done
            aws ec2 delete-route-table --route-table-id $rtb || true
          done

          for lb in $(aws elbv2 describe-load-balancers --query 'LoadBalancers[*].LoadBalancerArn' --output text); do
            aws elbv2 delete-load-balancer --load-balancer-arn $lb || true
          done

          for subnet in $(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output text); do
            aws ec2 delete-subnet --subnet-id $subnet || true
          done

          for sg in $(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" --query 'SecurityGroups[?GroupName!=`default`].GroupId' --output text); do
            aws ec2 delete-security-group --group-id $sg || true
          done


      - name: Run Destroy base-cluster
        if: always()
        run: |
          cd self-hosted/terraform/examples/aws/base-cluster
          terraform destroy -auto-approve
