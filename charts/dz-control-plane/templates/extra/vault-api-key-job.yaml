{{- if .Values.vault.job.enabled | default false -}}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-job-sa
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-job-role
rules:
  - apiGroups: [""]
    resources: ["pods", "endpoints"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "create", "update", "patch", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-job-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-job-role
subjects:
  - kind: ServiceAccount
    name: vault-job-sa
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "devzero.resourceName" (dict "ctx" . "component" "vault") }}-init-script
data:
  init.sh: |
    #!/bin/bash

    echo "Installing resources..."
    apt-get update && apt-get install -y curl unzip jq > /dev/null
    # Download and install Vault binary
    curl -LO https://releases.hashicorp.com/vault/1.17.2/vault_1.17.2_linux_amd64.zip > /dev/null
    unzip vault_1.17.2_linux_amd64.zip > /dev/null
    mv vault /usr/local/bin/
    rm vault_1.17.2_linux_amd64.zip

    echo "Resources installed successfully."

    # Verify installation
    echo "Vault version: $(vault version)"


    # Get the first endpoint defined in the Vault service, so we send all requests to the same pod
    VAULT_POD_IP=$(kubectl get endpoints vault -o jsonpath='{.subsets[0].addresses[0].ip}:{.subsets[0].ports[?(@.port==8200)].port}')

    # Set Vault address
    export VAULT_ADDR="http://$VAULT_POD_IP"
    echo "VAULT_ADDR: $VAULT_ADDR"

    VAULT_SECRET_KEYS_NAME="vault-unseal-keys"

    # Check if Vault is initialized
    if ! vault status | grep -q 'Initialized.*true'; then
      echo "Vault is not initialized. Initializing now..."

      # Initialize Vault with 5 Shamir keys and 3 required to unseal
      vault operator init -key-shares=5 -key-threshold=3 > init_output.txt

      # Extract keys and root token
      unseal_keys=$(grep 'Unseal Key' init_output.txt | awk '{print $4}')
      root_token=$(grep 'Initial Root Token' init_output.txt | awk '{print $4}')

      # Verify that keys and token were extracted successfully
      if [ -z "$unseal_keys" ] || [ -z "$root_token" ]; then
        echo "Failed to extract unseal keys or root token from initialization output"
        echo "This likely means that vault was already initialized. Skipping updating secret..."

      else
        echo "Successfully extracted unseal keys and root token"

        # Delete existing secret if it exists
        if kubectl get secret "$VAULT_SECRET_KEYS_NAME" &>/dev/null; then
          echo "Deleting existing Kubernetes secret for new keys..."
          kubectl delete secret "$VAULT_SECRET_KEYS_NAME"
        fi

        echo "Creating new Kubernetes secret..."
        kubectl create secret generic "$VAULT_SECRET_KEYS_NAME" --from-literal=keys="$unseal_keys" --from-literal=root-token="$root_token"

      fi


      echo "Vault initialized and keys stored in Kubernetes secret."
    fi

    echo "Vault is already initialized."

    # Get all the IP addresses for the "vault" service endpoints
    endpoints=$(kubectl get endpoints vault -o jsonpath='{.subsets[*].addresses[*].ip}')

    echo "Vault endpoints: $endpoints"

    # Retrieve keys from Kubernetes secret
    unseal_keys=$(kubectl get secret "$VAULT_SECRET_KEYS_NAME" -o jsonpath='{.data.keys}' | base64 --decode)

    # Loop through each IP and echo it
    for ip in $endpoints; do
      ip="$ip:8200"

      # Set Vault address
      export VAULT_ADDR="http://$ip"
      echo "VAULT_ADDR: $VAULT_ADDR"

      # Check if Vault is sealed
      if vault status | grep -q 'Sealed.*true'; then
        echo "Vault is sealed on $ip. Unsealing now..."

        # Read keys line by line and unseal until successful
        while IFS= read -r key; do
          vault operator unseal "$key" | grep 'Unseal Progress'

          # Check if vault is still sealed
          if ! vault status | grep -q 'Sealed.*true'; then
            echo "Vault successfully unsealed!"
            break
          fi
        done <<< "$unseal_keys"
      else
        echo "Vault is already unsealed."
      fi
    done
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "devzero.resourceName" (dict "ctx" . "component" "vault") }}-unseal
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-6"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
  labels:
    {{- include "devzero.labels" (dict "ctx" . "component" "vault") | nindent 4 }}
spec:
  backoffLimit: 0
  template:
    metadata:
      labels:
        {{- include "devzero.podLabels" (dict "ctx" . "component" "vault") | nindent 8 }}
    spec:
      serviceAccountName: vault-job-sa
      restartPolicy: OnFailure
      securityContext:
        runAsUser: 0
      containers:
        - name: vault-unseal
          image: bitnami/kubectl:1.30.7
          command: ["/bin/bash"]
          args: ["/scripts/init.sh"]
          volumeMounts:
            - name: init-script
              mountPath: /scripts
      volumes:
        - name: init-script
          configMap:
            name: {{ include "devzero.resourceName" (dict "ctx" . "component" "vault") }}-init-script
            defaultMode: 0755
---
# This cronjob is likely unnecessary, but allows manually triggering the unseal job. It will only run automatically once a year.
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "devzero.resourceName" (dict "ctx" . "component" "vault") }}-annual-unseal
  labels:
    {{- include "devzero.labels" (dict "ctx" . "component" "vault") | nindent 4 }}
spec:
  schedule: "0 0 1 1 *"  # Run at 00:00 on January 1
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      backoffLimit: 0
      template:
        metadata:
          labels:
            {{- include "devzero.podLabels" (dict "ctx" . "component" "vault") | nindent 12 }}
        spec:
          serviceAccountName: vault-job-sa
          restartPolicy: OnFailure
          securityContext:
            runAsUser: 0
          containers:
            - name: vault-unseal
              image: bitnami/kubectl:1.30.7
              command: ["/bin/bash"]
              args: ["/scripts/init.sh"]
              volumeMounts:
                - name: init-script
                  mountPath: /scripts
          volumes:
            - name: init-script
              configMap:
                name: {{ include "devzero.resourceName" (dict "ctx" . "component" "vault") }}-init-script
                defaultMode: 0755
{{- end }}
